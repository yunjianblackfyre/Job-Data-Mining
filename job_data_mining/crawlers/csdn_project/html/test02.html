<!DOCTYPE html>
<html>

	<head>

		<meta charset="utf-8">
		<meta http-equiv="pragma" content="no-cache">
		<meta http-equiv="cache-control" content="no-cache">
		<meta http-equiv="expires" content="0">
		<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
		<meta http-equiv="Content-Language" content="zh-cn" />
		<meta name="robots" content="all" />
		<link rel="stylesheet" rev="stylesheet" href="css/public-detail.css" type="text/css" media="screen" />
		<script type="text/javascript">
			var is_app = 1;
		</script>
	</head>

	<body ontouchstart>

		<div class="wapper" id="page_main">
			<!--主内容区域-begin-->
			<div class="detail-box">
				<h2 class="q-title">阿拉说资讯</h2>
				<div class="q-content">
					<!-- 插入开始内容 -->

					<div id="article_content" class="article_content csdn-tracking-statistics tracking-click" data-mod="popu_519" data-dsm="post">
						<div class="markdown_views">
							<h1 id="metaobject-model系统">Meta_Object Model系统</h1>

							<p>Qt meta-object系统基于三个方面：</p>

							<ol>
								<li>QObject提供一个基类， 方便派生类使用meta-object系统的功能；</li>
								<li>Q_OBJECT宏，在类的声明体内激活meta-object功能，比如动态属性、信号、槽；</li>
								<li>Meta Object编译器（MOC），为每个QObject派生类生成代码，已支持meta-object功能。</li>
							</ol>

							<p>QObject定义了从一个QObject对象访问meta-object功能的接口Q_OBJECT宏用来告诉编译器该类需要激活meta-object功能编译器在扫描一个源文件时如果发现类的声明中有这个宏就会生成一些代码来为支持meta-object功能——主要是生成该类对应 MetaObject类以及对QObject的函数override。</p>

							<p>QObject和QMetaObject： <br> 顾名思义QMetaObject包含了QObject的所谓的元数，也就是QObject信息的一些描述信息除了类型信息还包含QT中特有的signal&amp;slot信息。
							</p>

							<p>QObject::metaObject()方法返回一个QObject对象对应的metaobject对象，注意这个方法是virtual方法。如上文所说，如果一个类的声明中包含了Q_OBJECT宏，编译器会生成代码来实现这个类对应的QMetaObject类，并重载QObject::metaObject()方法来返回这个QMetaObject类的实例引用。这样当通过QObject类型的引用调用metaObejct方法时，返回的是这个引用的所指的真实对象的 metaobject。</p>

							<p>如果一个类从QObject派生，确没有声明Q_OBJECT宏，那么这个类的metaobject对象不会被生成，这样这个类所声明的signal&amp;slot都不能使用，而这个类实例调用metaObject()返回的就是其父类的metaobject对象，这样导致的后果就是你从这个类实例获得的元数据其实都是父类的数据，这显然给你的代码埋下隐患。<strong>因此如果一个类从QObject派生，它都应该声明Q_OBJECT宏，不管这个类有没有定义 signal&amp;slot和Property。</strong></p>

							<p>除了为对象间的通信提供信号与槽（引入元对象系统的主要原因）机制外，元对象还提供以下特性：</p>

							<ul>
								<li>QObject::metaObject()返回类关联的meta-object对象。</li>
								<li>QMetaObject::className()在运行时以字符串的形式返回类名，无需C++编译器提供运行时类别信息（RTTI）的支持。</li>
								<li>QObject::inherits()返回一个对象是否是QObject继承树上一个类的实例。</li>
								<li>QObject::tr()和QObject::trUtf8()提供国际化支持，将字符串翻译成指定的语言。</li>
								<li>QObject::setProperty()和QObject::property()通过名称动态设置和获取属性。</li>
								<li>QMetaObject::newInstance()构造类的一个新实例。</li>
							</ul>

							<h2 id="类型转换">类型转换</h2>

							<p>除此之外，还可以用qobject_cast()动态转换QObject类的类型。qobject_cast()函数和标准C++的dynamic_cast()功能类似，<strong>它的优点在于：不需要RTTI的支持，而且可以跨越动态连接库的转换。</strong>它尝试将它的参数转换成尖括号内的指针类型，如果对象是正确的类型（在运行时检查），则返回非零指针；否则，返回0，说明对象类型不兼容。</p>

							<p>例如，假设MyWidget继承自QWidget，同时也声明了Q_OBJECT宏。</p>

							<pre class="prettyprint"><code class="language-c++ hljs fix"><span class="hljs-attribute">QObject *obj </span>=<span class="hljs-string"> new MyWidget;</span></code></pre>

							<p>QObject *类型的变量obj实际上指向一个MyWidget对象，因此，我们可以适当地进行类型转换：</p>

							<pre class="prettyprint"><code class="language-c++ hljs fix"><span class="hljs-attribute">QWidget *widget </span>=<span class="hljs-string"> qobject_cast&lt;QWidget *&gt;(obj);</span></code></pre>

							<p>因为obj实际上是一个MyWidget，而MyWidget是QWidget的子类，所以，从QObject转换为QWidget成功了。既然知道了obj是MyWidget类型的，那么我们也可以将其转换为MyWidget *：</p>

							<pre class="prettyprint"><code class="language-c++ hljs fix"><span class="hljs-attribute">MyWidget *myWidget </span>=<span class="hljs-string"> qobject_cast&lt;MyWidget *&gt;(obj);</span></code></pre>

							<p>到MyWidget类型的转换也是成功的，因为qobject_cast()并不区分内建的Qt类型和自定义类型。可是，转换到QLabel却失败了，返回的指针为0。</p>

							<pre class="prettyprint"><code class="language-c++ hljs vhdl">QLabel *<span class="hljs-keyword">label</span> = qobject_cast&lt;QLabel *&gt;(obj);// <span class="hljs-keyword">label</span> 为 <span class="hljs-number">0</span></code></pre>

							<h2 id="qmetaobject">QMetaObject</h2>

							<p>每个QObject类都有一个对应的QMetaObject类，形成一个平行的类型层次。</p>

							<p>QMetaObject提供的信息： <br> 下面通过QMetaObject的接口来解读QMetaObject提供的信息：
							</p>

							<p>1、基本信息</p>

							<pre class="prettyprint"><code class="language-c++ hljs cs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * className () <span class="hljs-keyword">const</span>；
<span class="hljs-keyword">const</span> QMetaObject * superClass () <span class="hljs-keyword">const</span></code></pre>

							<p>2、classinfo： 提供额外的类信息。其实就是一些名值对。 用户可以在类的声明中以Q_CLASSINFO(name, value)方式添加。</p>

							<pre class="prettyprint"><code class="language-c++ hljs cs"><span class="hljs-keyword">int</span> classInfoCount () <span class="hljs-keyword">const</span>
<span class="hljs-keyword">int</span> classInfoOffset () <span class="hljs-keyword">const</span>
QMetaClassInfo classInfo ( <span class="hljs-keyword">int</span> index ) <span class="hljs-keyword">const</span>
<span class="hljs-keyword">int</span> indexOfClassInfo ( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * name ) <span class="hljs-keyword">const</span></code></pre>

							<p>3、contructor：提供该类的构造方法信息</p>

							<pre class="prettyprint"><code class="language-c++ hljs delphi">QMetaMethod <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-params">( int <span class="hljs-keyword">index</span> )</span> <span class="hljs-title">const</span>
<span class="hljs-title">int</span> <span class="hljs-title">constructorCount</span> <span class="hljs-params">()</span> <span class="hljs-title">const</span>
<span class="hljs-title">int</span> <span class="hljs-title">indexOfConstructor</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> char * <span class="hljs-keyword">constructor</span> )</span> <span class="hljs-title">const</span></span></code></pre>

							<p>4、enum：描述该类声明体中所包含的枚举类型信息</p>

							<pre class="prettyprint"><code class="language-c++ hljs cs">QMetaEnum enumerator ( <span class="hljs-keyword">int</span> index ) <span class="hljs-keyword">const</span>
<span class="hljs-keyword">int</span> enumeratorCount () <span class="hljs-keyword">const</span>
<span class="hljs-keyword">int</span> enumeratorOffset () <span class="hljs-keyword">const</span>
<span class="hljs-keyword">int</span> indexOfEnumerator ( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * name ) <span class="hljs-keyword">const</span></code></pre>

							<p>5、method：描述类中所包含方法信息：包括property,signal,slot等，包括祖先类，如何组织暂时不确定。</p>

							<pre class="prettyprint"><code class="language-c++ hljs oxygene">QMetaMethod <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-params">( int <span class="hljs-keyword">index</span> )</span> <span class="hljs-title">const</span>
<span class="hljs-title">int</span> <span class="hljs-title">methodCount</span> <span class="hljs-params">()</span> <span class="hljs-title">const</span>
<span class="hljs-title">int</span> <span class="hljs-title">methodOffset</span> <span class="hljs-params">()</span> <span class="hljs-title">const</span>

<span class="hljs-title">int</span> <span class="hljs-title">indexOfMethod</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> char * <span class="hljs-keyword">method</span> )</span> <span class="hljs-title">const</span>
<span class="hljs-title">int</span> <span class="hljs-title">indexOfSignal</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> char * signal )</span> <span class="hljs-title">const</span>
<span class="hljs-title">int</span> <span class="hljs-title">indexOfSlot</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> char * slot )</span> <span class="hljs-title">const</span></span></code></pre>

							<p>6、property：类型的属性信息</p>

							<pre class="prettyprint"><code class="language-c++ hljs cs">QMetaProperty property ( <span class="hljs-keyword">int</span> index ) <span class="hljs-keyword">const</span>
<span class="hljs-keyword">int</span> propertyCount () <span class="hljs-keyword">const</span>
<span class="hljs-keyword">int</span> propertyOffset () <span class="hljs-keyword">const</span>
<span class="hljs-keyword">int</span> indexOfProperty ( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * name ) <span class="hljs-keyword">const</span>
QMetaProperty userProperty () <span class="hljs-keyword">const</span>  <span class="hljs-comment">//返回类中设置了USER flag的属性</span></code></pre>

							<p>注意：对于类里面定义的函数，构造函数，枚举，只有加上一些宏才表示你希望为方法提供meta信息。比如 Q_ENUMS用来注册宏，Q_INVACABLE用来注册方法（包括构造函数）。Qt这么设计的原因应该是避免meta信息的臃肿。</p>

							<h2 id="moc文件分析">moc文件分析</h2>

							<p>我们知道Qt不是使用的“标准的” C++语言，而是对其进行了一定程度的“扩展”。这里我们从Qt新增加的关键字就可以看出来：signals、slots 或者 emit。所以有人会觉得 Qt 的程序编译速度慢，这主要是因为在 Qt 将源代码交给标准 C++ 编译器，如 gcc 之前，需要事先将这些扩展的语法去除掉。完成这一操作的就是 moc。 <br> moc 全称是 Meta-Object Compiler，也就是“元对象编译器”。Qt 程序在交由标准编译器编译之前，先要使用 moc 分析 C++ 源文件。如果它发现在一个头文件中包含了宏 Q_OBJECT，则会生成另外一个 C++ 源文件。这个源文件中包含了 Q_OBJECT 宏的实现代码。这个新的文件名字将会是原文件名前面加上 moc_ 构成。这个新的文件同样将进入编译系统，最终被链接到二进制代码中去。因此我们可以知道，这个新的文件不是“替换”掉旧的文件，而是与原文件一起参与编译。另外，我们还可以看出一点，moc 的执行是在预处理器之前。因为预处理器执行之后，Q_OBJECT 宏就不存在了。</p>

							<h2 id="总结">总结</h2>

							<p>至此，我们应该是对Qt Meta-Object Model有了一个清楚的认识</p>

							<ul>
								<li>Qt提供了一个QObject的基类</li>
								<li>Qt扩展了C++语法，提供了Q_OBJECT、Q_INVOKABLE、signals、slots、emit、SIGNAL，SLOT、Q_PROPERT、Q_ENUM、Q_FLAG、Q_CLASSINFO等宏，moc会识别这些宏并生成对应的moc源代码</li>
								<li>Q_OBJECT宏中声明了QMetaObject的静态对象，QMetaObject中记录了classinfo、method、property、enum，并提供了metacall来操作</li>
							</ul>
						</div>
						<link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/production/markdown_views-ea0013b516.css">
					</div>

					<!--插入结束内容-->
				</div>
				<script src="js/zepto.min.js" type="text/javascript"></script>
				<script src="js/zepto.model.js" type="text/javascript"></script>
	</body>

</html>